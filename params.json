{"name":"Super-request","tagline":"super-request is a supertest inspired HTTP assertion tester.","body":"[![build status](https://secure.travis-ci.org/doug-martin/super-request.png)](http://travis-ci.org/doug-martin/super-request)\r\n\r\n# Super Request\r\n\r\n`super-request` is a [`supertest`](https://github.com/visionmedia/supertest) inspired HTTP assertion tester.\r\n\r\n## About\r\n\r\n`super-request` is very similar to `supertest` except that it leverages the [`request`](https://github.com/mikeal/request) module and supports sessions and chaining of HTTP requests.\r\n\r\n## Installation\r\n\r\n`npm install super-request`\r\n\r\n## Example\r\n\r\n```javascript\r\n\r\nvar request = require('super-request'),\r\n\texpress = require('express');\r\n\r\nvar app = express();\r\n\r\napp.use(express.cookieParser());\r\napp.use(express.cookieSession({secret: \"super-request123\"}));\r\n\r\napp.get('/login', function (req, res) {\r\n\treq.session.loggedIn = true;\r\n\tres.send(\"logged in\");\r\n});\r\n\r\napp.get('/', function (req, res) {\r\n\tif (req.session.loggedIn) {\r\n\t\treq.session.loggedIn = true;\r\n\t\tres.send(\"loggedIn\");\r\n\t} else {\r\n\t\tres.send(\"notLoggedIn\");\r\n\t}\r\n});\r\n\r\nrequest(app)\r\n\t.get('/login')\r\n\t.expect(200, \"logged in\")\r\n\t.end()\r\n\t//after we logged in perform this request in the same session!\r\n\t.get(\"/\")\r\n\t.expect(200, \"loggedIn\")\r\n\t.end(function(err){\r\n\t\tif(err){\r\n\t\t\tthrow err;\r\n\t\t}\r\n\t});\r\n```\r\n\r\n## Using with testing frameworks\r\n\r\n### Mocha\r\n\r\nHere is an example using with `mocha`.\r\n\r\n```javascript\r\ndescribe('GET /users', function(){\r\n  it('respond with json', function(done){\r\n    request(app)\r\n      .get('/user')\r\n      .set('Accept', 'application/json')\r\n      .expect('Content-Type', /json/)\r\n      .expect(200, done);\r\n  })\r\n})\r\n```\r\n\r\n`super-request` also returns a promise so you can use it with promise based test frameworks here is an an example using `it` and returning a promise.\r\n\r\n```javascript\r\n\r\nit.describe('GET /users', function(it){\r\n  it.should('respond with json', function(){\r\n    return request(app)\r\n      \t.get('/user')\r\n      \t.set('Accept', 'application/json')\r\n      \t.expect('Content-Type', /json/)\r\n      \t.expect(200)\r\n      \t.end();\r\n  });\r\n});\r\n\r\n```\r\n\r\n\r\n## API\r\n\r\n**`.expect(status[, fn])`**\r\n\r\nAssert response status code.\r\n\r\n**`.expect(status, body[, fn])`**\r\n\r\nAssert response status code and body.\r\n\r\n**`.expect(body[, fn])`**\r\n\r\nAssert response body text with a string, regular expression, or parsed body object.\r\n\r\n**`.expect(field, value[, fn])`**\r\n\r\nAssert header field value with a string or regular expression.\r\n\r\n**`.end(fn)`**\r\n\r\nPerform the request and invoke fn(err, res).\r\n\r\n`super-request` is a wrapper on top of `request` so any options you can specify with request you can also set using the chainable api, by invoking a function with the same name as the option you wish to set.\r\n\r\n**Methods** (see [`request`](https://github.com/mikeal/request))\r\n\r\nAll option methods listed below allow functions to be passed as the argument in place of the default value.  The function must return a valid object, int, string etc. that the option would normally accept.  See the \"[Simple token-auth example](#simple-token-auth-example)\" below.\r\n\r\n* `uri` || `url` - fully qualified uri or a parsed url object from url.parse()\r\n* `qs` - object containing querystring values to be appended to the uri\r\n* `method` - http method, defaults to GET\r\n* `headers` - http headers, defaults to {}\r\n* `body` - entity body for POST and PUT requests. Must be buffer or string.\r\n* `form` - when passed an object this will set `body` but to a querystring representation of value and adds `Content-type: application/x-www-form-urlencoded; charset=utf-8` header. When passed no option a FormData instance is returned that will be piped to request.\r\n* `json` - sets `body` but to JSON representation of value and adds `Content-type: application/json` header.  Additionally, parses the response body as json.\r\n* `multipart` - (experimental) array of objects which contains their own headers and `body` attribute. Sends `multipart/related` request. See example below.\r\n* `followRedirect` - follow HTTP 3xx responses as redirects. defaults to true.\r\n* `followAllRedirects` - follow non-GET HTTP 3xx responses as redirects. defaults to false.\r\n* `maxRedirects` - the maximum number of redirects to follow, defaults to 10.\r\n* `encoding` - Encoding to be used on `setEncoding` of response data. If set to `null`, the body is returned as a Buffer.\r\n* `pool` - A hash object containing the agents for these requests. If omitted this request will use the global pool which is set to node's default maxSockets.\r\n* `pool.maxSockets` - Integer containing the maximum amount of sockets in the pool.\r\n* `timeout` - Integer containing the number of milliseconds to wait for a request to respond before aborting the request\r\n* `proxy` - An HTTP proxy to be used. Support proxy Auth with Basic Auth the same way it's supported with the `url` parameter by embedding the auth info in the uri.\r\n* `oauth` - Options for OAuth HMAC-SHA1 signing, see documentation above.\r\n* `strictSSL` - Set to `true` to require that SSL certificates be valid. Note: to use your own certificate authority, you need to specify an agent that was created with that ca as an option.\r\n* `jar` - Set to `false` if you don't want cookies to be remembered for future use or define your custom cookie jar (see examples section)\r\n* `aws` - object containing aws signing information, should have the properties `key` and `secret` as well as `bucket` unless you're specifying your bucket as part of the path, or you are making a request that doesn't use a bucket (i.e. GET Services)\r\n\r\n```javascript\r\nrequest(app)\r\n\t.post(\"/login\")\r\n\t.form({username : \"username\", password : \"password\"})\r\n\t.expect(200)\r\n\t.expect({loggedIn : true})\r\n\t.end(function(err){\r\n\t\tif(err){\r\n\t\t\tthrow err;\r\n\t\t}\r\n\t});\r\n\r\n```\r\n\r\nTo upload data to a server\r\n\r\n```javascript\r\nrequest(app)\r\n\t.post(\"/upload/csv\")\r\n\t.headers({'content-type': 'multipart/form-data'})\r\n\t.multipart([\r\n\t\t{\r\n\t\t\t'Content-Disposition': 'form-data; name=\"file\"; filename=\"my.csv\"',\r\n\t\t\t'Content-Type': 'text/csv',\r\n\t\t\tbody: fs.readFileSync(path.resolve(__dirname, \"./assets/my.csv\"))\r\n\t\t}\r\n\t])\r\n\t.expect(200)\r\n\t.expect(\"content-type\", \"text/plain\")\r\n\t.end(function(err){\r\n\t\tif(err){\r\n\t\t\tthrow err;\r\n\t\t}\r\n\t});\r\n\r\n```\r\n\r\n### Chaining requests\r\n\r\n`super-request` supports chaining of requests, this is particularly useful if you need to login to your server and then perform a request.\r\n\r\n```javascript\r\nrequest(app)\r\n\t.post(\"/login\")\r\n\t.form({username : \"username\", password : \"password\"})\r\n\t.expect(200)\r\n\t.expect({loggedIn : true})\r\n\t.end() //this request is done\r\n\t//now start a new one in the same session\r\n\t.get(\"/some/protected/route\")\r\n\t.expect(200, {hello : \"world\"})\r\n\t.end(function(err){\r\n\t\tif(err){\r\n\t\t\tthrow err;\r\n\t\t}\r\n\t});\r\n\r\n```\r\n\r\n**Note** You must call end on the current request before you can start a new one.\r\n\r\n### Simple token-auth example\r\n\r\nUsing everything learned above, let's try a more complex example.  This example illustrates using functions as the argument for your options.  This is useful for request chains that need to lazily evaluate a value returned from your http api.  Consider the extremely simplified example of a token authentication flow:\r\n\r\n```javascript\r\n/**\r\n *  Webserver setup\r\n**/\r\nvar request = require('super-request'),\r\n\texpress = require('express'),\r\n\tapp = express();\r\n\r\napp.use(express.bodyParser());\r\napp.use(express.cookieParser());\r\napp.use(express.cookieSession({secret: 'super-request123'}));\r\n\r\n// a public available route, must post email/password to the body\r\napp.post('/login', function (req, res) {\r\n    var body = req.body;\r\n    if (!!body.email && !!body.password) {\r\n        req.session.token = Math.random();\r\n        res.send(''+req.session.token);\r\n    } else {\r\n        res.send(400)\r\n    }\r\n});\r\n\r\n// a \"private\" route that requires a valid token in the query string.\r\napp.get('/', function (req, res) {\r\n    var query = req.query || {};\r\n    if (query.token && parseFloat(query.token) === req.session.token) {\r\n        res.send('tokenValid');\r\n    } else {\r\n        res.send(401);\r\n    }\r\n});\r\n\r\n// create a request super-request\r\nvar token;\r\nrequest(app)\r\n    .post('/login')\r\n    .form({\r\n        email: 'john@isp.com',\r\n        password: 'pass1234'\r\n    })\r\n    .expect(200)\r\n    .end(function (err, res, body) {\r\n\t\t// store the token, we will use it later in the request chain.\r\n        token = body;\r\n    })\r\n    // after we have our token, adding the token to the query string gives access to protected routes\r\n    // note: querystrings are an unsafe option for token auth in production, but works for a simple example.\r\n    .get('/')\r\n    .qs(function () {\r\n        return {token: token};\r\n    })\r\n    .expect(200, 'tokenValid')\r\n    .end()\r\n    // a request without a token or a bogus token protected routes cannot be reached.\r\n    .get('/')\r\n    .expect(401)\r\n    .end(function(err){\r\n\t\tif(err){\r\n\t\t\tthrow err;\r\n\t\t}\r\n\t});\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}